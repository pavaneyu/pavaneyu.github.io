<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pavane</title>
  
  
  <link href="https://pavaneyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://pavaneyu.github.io/"/>
  <updated>2022-02-20T07:44:20.582Z</updated>
  <id>https://pavaneyu.github.io/</id>
  
  <author>
    <name>OuyangYu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试总结</title>
    <link href="https://pavaneyu.github.io/2022/02/19/%E9%9D%A2%E8%AF%95/"/>
    <id>https://pavaneyu.github.io/2022/02/19/%E9%9D%A2%E8%AF%95/</id>
    <published>2022-02-19T06:02:27.542Z</published>
    <updated>2022-02-20T07:44:20.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-equals与-x3D-x3D"><a href="#1-equals与-x3D-x3D" class="headerlink" title="1.equals与&#x3D;&#x3D;"></a>1.equals与&#x3D;&#x3D;</h1><ul><li>&#x3D;&#x3D;比较地址,即比较是否为同一个对象     equals用来比较内容,默认用&#x3D;&#x3D;实现,往往需要重写</li></ul><h1 id="2-重写了equals-，还要重写hashCode-？"><a href="#2-重写了equals-，还要重写hashCode-？" class="headerlink" title="2.重写了equals()，还要重写hashCode()？"></a>2.重写了equals()，还要重写hashCode()？</h1><ul><li><p>hashcode()方法返回哈希码值  用于提高哈希表性能,  不同对象的值基本不一样</p></li><li><p>如果只重写了<strong>equals</strong>,   我们new 出了两个<strong>属性相同的对象</strong>,  但是地址不同，</p></li><li><p>这时候equals比较属性是true，但是两个对象的hashCode是不相等的</p></li><li><p>也就是我们需要遵循一个原则, equals 为 true ， hashCode 必须相等</p></li></ul><p>往HashMap添加元素的时候，需要hashcode方法定位到在数组的位置</p><p>没有重写 hashCode 方法，两个对象equans为true   那么就无法定位到同一个位置，集合还是会插入元素</p><p>出现重复元素,重写的equals方法就没意义了</p><h1 id="3-Collecttions单列集合"><a href="#3-Collecttions单列集合" class="headerlink" title="3.Collecttions单列集合"></a>3.Collecttions单列集合</h1><ul><li>List,线程不安全,有序,可以重复<ul><li>arrylist 底层由数组实现,根据下标来索引,所以查询效率高,增删效率低</li><li>扩容:默认容量0,第一次添加扩到10,此后1.5倍扩容  指定容量时,1.5扩容  </li><li>LinkedList 底层是双向链表,增删效率高,查询效率低</li></ul></li></ul><ul><li><p>Set,HashSet   无序,不可以重复</p><ul><li><p><em>hashset</em>底层是hashmap ,而hashmap底层是数组+链表+红黑树</p><p>​                                                                                             没有就加入 </p></li><li><p>添加元素:1.得到元素hash值,再转成索引值 2.查table                           为真添加,</p><p>​                                                                                             有就equals,   为假不添加</p></li><li><p>底层hashmap的扩容:</p><ul><li>第一次扩到16,到临界值后双倍扩容,再到新的临界值后以此类推</li><li>临界值为当前容量*加载因子,默认0.75</li><li>如果链表个数大于等于8,且table大小大于等于64,转成红黑树</li></ul></li></ul></li></ul><h1 id="4-接口和抽象类"><a href="#4-接口和抽象类" class="headerlink" title="4.接口和抽象类"></a>4.接口和抽象类</h1><ul><li><p>抽象类必须至少有一个抽象方法,子类必须重写所有抽象方法<br>如果不是抽象方法(有方法体),则可以不用重写</p></li><li><p>接口中方法默认没有方法体, 接口实现类必须重写所有非default方法</p><p>default可以有默认实现 </p></li><li><p>因为单继承,继承了抽象类就不能继承其他类了</p></li><li><p>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。</p></li></ul><img src="https://s2.loli.net/2022/02/19/ShMuALDo4X96aGT.png" alt="image.png" style="zoom:50%;"><p>int和Integer</p><ul><li>int是基本类型,Integer是包装类型,是面向对象的</li><li>未初始化 int默认为0,Integer 默认为null</li><li>int 比较内容用&#x3D;&#x3D;   Integer比较内容用equals</li><li>Integer在-128到127内有缓存, 在这中间不新建对象</li><li>临时使用时用int, 自己分配在栈上   定义pojo时用Integer,保证序列化</li></ul><p>JVM分为哪些区?</p><ul><li>堆:被所有线程共享,存放对象和数组, 是GC的主要区域</li><li>栈:每个线程都有一个栈,存放一些局部变量</li><li>程序计数器:当前线程执行的字节码的行指示器</li><li>方法区:所有线程共享,包含所有类信息和静态变量</li></ul><p>实现多线程方式</p><ul><li>1.继承Thread  ,重写run()</li><li>实现Runnable接口 ,重写run()\</li><li>实现Callable,重写call() 有一个返回值</li><li>通过线程池创建线程, 使用线程池接口ExecutorService</li></ul><p>禁止使用Executor创建线程池?</p><ul><li>Executor最大线程数为2147483647,如果达到上限就会OOM</li><li>workQueue参数为 new LinkedBlockingQueue(),容量为最大int值,如果瞬间请求非常大,就会OOM</li></ul><p>如何避免死锁</p><ul><li>资源互斥   threadlocal </li><li>请求资源的同时,对已获得的资源保持不放</li><li>不强行剥夺,未使用完资源之前不强行剥夺</li><li>两个线程循环等待————-将系统资源设置标识位,规定所有线程申请资源</li></ul><p>多线程</p><p>volatile  强制把L1L2Cash  数据 刷到主线程 ,这样每个线程都看到</p><h1 id="MVC流程-以dispatchServlet为核心-7步"><a href="#MVC流程-以dispatchServlet为核心-7步" class="headerlink" title="MVC流程 ?   以dispatchServlet为核心   7步"></a>MVC流程 ?   以dispatchServlet为核心   7步</h1><p><img src="https://s2.loli.net/2022/02/19/Fn2MYA4HJavwQfd.png" alt="SpringMVC.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-equals与-x3D-x3D&quot;&gt;&lt;a href=&quot;#1-equals与-x3D-x3D&quot; class=&quot;headerlink&quot; title=&quot;1.equals与&amp;#x3D;&amp;#x3D;&quot;&gt;&lt;/a&gt;1.equals与&amp;#x3D;&amp;#x3D;&lt;/h1&gt;&lt;ul&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://pavaneyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>MQ消息队列</title>
    <link href="https://pavaneyu.github.io/2022/02/17/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>https://pavaneyu.github.io/2022/02/17/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2022-02-17T08:44:34.942Z</published>
    <updated>2022-02-20T07:44:55.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解耦-异步-削峰"><a href="#解耦-异步-削峰" class="headerlink" title="解耦 异步  削峰"></a>解耦 异步  削峰</h1><p><a href="https://www.bilibili.com/video/BV15Z4y1x7tE">视频</a></p><p>1.系统之间不产生依赖关系,增加和删除系统不会影响其他系统代码</p><img src="https://s2.loli.net/2022/02/16/Jt6UwFTRLhxqXfk.png" alt="image-20220216202439238" style="zoom:80%;"><p>2.不需要请求者等待,等结果处理完再返回结果</p><img src="https://s2.loli.net/2022/02/16/BTZgFlOz7VSvXj4.png" alt="image-20220216211043584" style="zoom:80%;"><p>3.流量缓冲</p><p><img src="https://s2.loli.net/2022/02/16/ZVw8BJiGtIhqaWn.png" alt="image-20220216211135531"></p><p>缺点,  系统复杂度提高   重复消费问题?  消息丢失?消息顺序?</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解耦-异步-削峰&quot;&gt;&lt;a href=&quot;#解耦-异步-削峰&quot; class=&quot;headerlink&quot; title=&quot;解耦 异步  削峰&quot;&gt;&lt;/a&gt;解耦 异步  削峰&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV15</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://pavaneyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis笔记</title>
    <link href="https://pavaneyu.github.io/2022/02/17/redis%E7%AC%94%E8%AE%B0/"/>
    <id>https://pavaneyu.github.io/2022/02/17/redis%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-17T08:28:50.667Z</published>
    <updated>2022-02-19T07:56:39.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><ol><li><p>Redis 为什么快？</p></li><li><p>Redis 有哪些常用的数据结构？</p><p>字符串类型：String</p><p>哈希类型：Hash</p><p>列表类型：List</p><p>集合类型：Set</p><p>有序集合类型zset</p><p>Redis中高级用户，HyperLogLog、Geo、Pub&#x2F;Sub</p></li><li><p>Redis RDB 和 AOF 持久化的区别，如何选择？</p></li><li><p>如何解决缓存击穿、缓存穿透、雪崩问题？</p></li><li><p>如何用 Redis 实现点赞功能，怎么设计 Key &#x2F; Value？</p></li></ol><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>基于内存，数据读写速度快，单机Redis能处理10W+的请求</li><li>单线程模型，避免了多线程频繁进行上下文切换的时间消耗</li><li>支持多种数据结构</li><li>基于非阻塞的多路复用IO机制</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>- </p><ol><li>String ,二进制安全,即可以包含任何序列化的对象,比如图片</li></ol><p>最大512M</p><p>简单动态字符串  类似ArrayList ,采用预分配冗余空间方式减少内存频繁分配</p><p>redis任何操作都是原子操作,即不会被其他线程打断</p><p>​    2.List :单键多值   底层是双向链表</p><ol start="3"><li><p>set:去重,无序    底层是hash表,所以CRUD的复杂度是O(1)</p></li><li><p>Hash:</p></li></ol><p>​    5.有序集合zset</p><p><img src="https://s2.loli.net/2022/02/18/wDro6MlgPOAa4KX.png"></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>redis中事务不保证原子性,所以要手动回滚</p><p><img src="https://s2.loli.net/2022/02/18/qFoQg5v6bntLpXr.png" alt="image-20220218145201511"></p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>单位GB大小写无所谓</p><p>导入其他文件</p><p>网络  bind ip注释掉  端口</p><p>通用 daemonize yes 以守护进程运行,默认no</p><p>持久化    save 60  100   在60s内进行100次key的修改,就持久化操作</p><p>密码</p><p>内存策略</p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB快照-默认"><a href="#RDB快照-默认" class="headerlink" title="RDB快照,默认"></a>RDB快照,默认</h2><p>1.满足自定义规则,执行flushall或者退出redis          会自动触发rdb</p><p>2.优点:适合大规模数据恢复,对数据完整性不高</p><p>3.缺点:操作需要时间间隔,最后一次修改的数据可能因为宕机而丢失</p><h2 id="ROF"><a href="#ROF" class="headerlink" title="ROF"></a>ROF</h2><p>1.每一次修改都同步,保证数据完整性</p><p>每秒同步一次,可能会丢失这一秒的数据</p><p>从不同步.效率最高</p><p>2.缺点,数据文件大,修复速度慢.运行效率低 </p><h1 id="键过期策略"><a href="#键过期策略" class="headerlink" title="键过期策略"></a>键过期策略</h1><p>  定时过期</p><p>惰性过期</p><p>定期过期</p><p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p><h1 id="内存淘汰策略-默认LRU-最近最少使用"><a href="#内存淘汰策略-默认LRU-最近最少使用" class="headerlink" title="内存淘汰策略 -默认LRU,最近最少使用"></a>内存淘汰策略 -默认LRU,最近最少使用</h1><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主以写为主,从以读为主,读写分离</p><p> 作用:数据冗余.故障恢复 ,负载均衡,是高可用的基石</p><p>一般单台redis服务器最大内存不超过20g</p><p>  环境配置:只配置从库</p><p>默认情况下,每台redis服务器都是主节点</p><p>全量复制 ,增量复制</p><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>监控主机是否故障,如果故障根据投票数,自动替换为主机</p><p>如果原来主机恢复,只能当做从机</p><p>优点:基于主从复制的优点      主从可以切换,故障可以转移,提高系统可用性    </p><p>缺点:不好在线扩容,配置麻烦</p><h1 id="缓存穿透-查询空的对象"><a href="#缓存穿透-查询空的对象" class="headerlink" title="缓存穿透(查询空的对象)"></a>缓存穿透(查询空的对象)</h1><p>同时大量查询一个空的对象,缓存没有只能去数据库查,数据库也没有结果,也不会在缓存中记录,所以每次这种请求就会直接到数据库</p><p>布隆过滤器 是一种数据结构,对所有可能查询的参数以hash形式存储,在控制层进行校验,不符合就丢弃,从而避免对数据库的查询压力</p><p>缓存空对象</p><h1 id="缓存击穿-一个key-在过期的时候导致"><a href="#缓存击穿-一个key-在过期的时候导致" class="headerlink" title="缓存击穿(一个key,在过期的时候导致)"></a>缓存击穿(一个key,在过期的时候导致)</h1><p>一个key不停地在抗大并发,当key在过期的瞬间,大并发就会直接访问到数据库</p><p>1.设置热点数据永不过期</p><p>2.加互斥锁,保证每个key只能有一个线程去数据库查询</p><h1 id="缓存雪崩-缓存集中失效或者redis宕机"><a href="#缓存雪崩-缓存集中失效或者redis宕机" class="headerlink" title="缓存雪崩 缓存集中失效或者redis宕机"></a>缓存雪崩 缓存集中失效或者redis宕机</h1><p>异地多活,保证redis高可用</p><p>限流降级,加锁保证一个key只允许一个线程查询</p><p>数据预热</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试问题&quot;&gt;&lt;a href=&quot;#面试问题&quot; class=&quot;headerlink&quot; title=&quot;面试问题&quot;&gt;&lt;/a&gt;面试问题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Redis 为什么快？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Redis 有哪些常用的数据结构？&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://pavaneyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>回顾java基础之一(多态,接口,异常,常用类,集合)</title>
    <link href="https://pavaneyu.github.io/2022/02/16/%E5%9B%9E%E9%A1%BEjava%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80/"/>
    <id>https://pavaneyu.github.io/2022/02/16/%E5%9B%9E%E9%A1%BEjava%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%B8%80/</id>
    <published>2022-02-16T08:05:57.314Z</published>
    <updated>2022-02-16T08:25:08.632Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ol start="5"><li>pubic  谁都可以<br>protected 同包和子类 可以访问<br>默认 同包可以访问<br>private  只有类内访问</li></ol><p>6.<strong>封装</strong>目的 隐藏实现细节  对数据进行验证安全 不然用户自己赋值,而是让\调用方法实现赋值</p><ul><li>实现 1.属性私有化,只能自己操作    2.对外提供只getset方法操作</li><li>在构造器中用set 可以防止通过 构造器直接赋值不安全数据</li></ul><p>7.直接打set 自动完成set方法</p><p>8.<strong>继承</strong>  实现代码复用  提高拓展性和可维护性放</p><ul><li><p>多个类存在相同属性和方法,可以抽象出父类</p></li><li><p>子类不能用父类的私有属性和方法,非私有的都能用</p></li><li><p><strong>子类构造器必须直接或间接调用父类构造器,完成对父类属性的初始化</strong>,分工明确<br> (间接调用:构造器中用this()调用其他参数的构造器,而后者调用super() ,同一构造器this()和super()不能同时用 )</p></li><li><p>默认自动隐式调用无参构造器,相当于自动super()</p></li><li><p>可以在第一行用super(参数)可以指定父类某一个构造器,如果父类没有无参构造器.则必须指定</p></li><li><p>如果子类有和父类重名的属性和方法,用super. 区分<br>如果没有重名,可以自己用,也可以super. this, 都一样</p></li></ul><p>-程序怎么识别某个方法呢?现在本类找有没有定义  再到父类一层一层找<br>9.override   重写覆盖父类  名字和参数严格一致的方法 </p><ul><li>override 方法返回类型必须是原方法返回类型的子类</li><li>override方法访问权限 只能大 不能小 </li><li>overload 只是本类同名方法的不同参数形式</li></ul><p>10.<strong>多态</strong> 提高代码复用性  便于维护拓展</p><ul><li>方法多态   父类方法中参数Animal  子类重写时参数可以是Dog类<br>11.上转型对象  Animal animal &#x3D;new Cat()<br>animal对象只能用她的编译类型的成员 ,只能用父类成员<br>Cat cat &#x3D;(Cat) animal   强制先下转型<br>12.方法的动态绑定  调用对象方法,方法与实际运行类型绑定<br>多态数组,父类定义的数组可以放子类,<br>13.&#x3D;&#x3D;判断基本类型时,值是否相等<br>    判断其他类型,判断地址<br> equal 默认用&#x3D;&#x3D;判断地址,子类重写以判断内容<br>所以判断内容时,用equal  (基本类型没有equal用&#x3D;&#x3D;)<br>  判断地址时用&#x3D;&#x3D;<br>14.hashcode()方法返回哈希码值  用于提高哈希表性能<br>不同对象的值不一样<br>15.toString() 默认返回全类名@十六进制的hashcode<br>直接输出对象默认调用toString()<br>16.finalize()在对象没有任何引用,需要被回收时自动调用,重写业务逻辑代码(释放数据库,打开的文件)<br>17.main方法<br>  java虚拟机静态调用main,无需创建对象. 接受编译命令,用作String数组参数<br>18.static 代码块 只会在类加载时执行一次<br>普通代码块每创建一次对象在构造器就执行一次</li></ul><p>类什么时候被加载?(new  子类加载时,父类也加载  使用类静态成员  )<br>静态代码块只能调用静态成员<br>构造器隐含了 1.super()  2.调用本普通代码块<br>19.子类创建对象时  调用顺序<br>    1.父类静态代码块和静态属性<br>    2.子类静态代码块和静态属性<br>    3.父类构造器(隐含执行普通代码块)<br>     4. 子类构造器(隐含执行普通代码块)<br>20.单例<br> 1.构造private防止直接new<br>2.类内声明一个private 静态对象<br>3.只向外暴露一个静态公共方法创建返回该对象<br>21.final<br>  1.不希望类被继承<br> 2.不希望方法可以被子类重写<br>3.不希望属性变量被修改,也叫产量,用大写下划线隔开<br>final+static 同时修饰,在调用时不会导致类被加载(底层优化了)<br>22.抽象类  是 设计者设计好之后 让子类继承并实现<br>抽象方法不能有方法体<br>一个非抽象类继承了抽象类,必须实现父类的所有抽象方法<br>抽象方法可以让不同类   同名方法的多态<br>23.接口<br>java8后接口里的默认实现方法和静态方法可以有方法体<br>接口就是 规范 实现的类 必须有的方法,且不同类的方法名 统一<br>接口中方法都是抽象方法,且public<br>接口中属性都是 public static fiinal<br>接口是对java单继承的补充<br>小猴子继承猴子的爬树方法,但是想要飞怎么办?实现飞翔的接口</p><p>接口的多态:多态参数 ,多态数组 ,多态传递(实现了A接口,也就实现了A父接口)<br>24.内部类:一般在方法中,可以直接访问外部类的所有成员,包括私有<br>内部类就像局部变量,不能加访问修饰,但是可以final<br>作用域仅在定义的方法中 其他方法中要访问内部类成员要通过创建其对象<br>匿名内部类,只用一次,可以当实参用<br>静态内部类:只能访问静态成员,外部类要使用内部类的成员要通过创建对象    如果成员重名,默认里面就近<br>25.枚举类:有限的几个值且不需要修改<br>1.enum 代替class<br>2.第一行   A(“agree”),B(“disagree”);<br>26.<br>错误:资源不足,堆溢出  内存不足 错误<br>异常:<br>运行时异常(检查不出来) :空指针 数组越界  类型转换  数字格式 数学运算   异常<br>编译时异常(不处理就没法运行)  网络数据库 文件</p><p>子类重写的方法抛出的异常 应该为 父方法抛出异常的子类<br>方法 throws 异常类<br>方法体中 throw  手动生成异常对象</p><p>27.Integer a &#x3D;45; 自动装箱调用valueof()时,数如果在-128到127内 不<br>创建新的对象</p><p>28.String a&#x3D;b+c; String对象相加 ,底层实现:<br>创建一个StringBuilder, 添加b,c   再转成String</p><p>String s&#x3D;”aaa” s指向常量池<br>String ss&#x3D;new String(“aaa”)   ss指向堆</p><p>常用方法:String.format(format,多个变量)<br>format 字符串中有占位符  %s  %d  %.2f  %c</p><p>29.StringBuffer()     无参构造器 默认容量为16<br>      StringBuffer( int capacity)  指定容量<br>      StringBuffer(String str)  指定内容    容量再次基础上+16<br>30.StringBuilder不具有线程安全,用作StringBuffer的简易替换<br>只在单个线程使用中,但比Buffer要快,优先使用<br>31.字符串很少修改—String<br>     大量修改,单线程—-StringBuilder<br>     大量修改,多线程—-StringBUffer<br> 32.Arrays.sort()自定义排序<br>System.out.println(Arrays.binarySearch(a, 8));<br> Integer[] newArr &#x3D; Arrays.copyOf(a, 2);<br>        Arrays.fill(newArr, 88);<br>Arrays.equals(a, newArr);<br>        List list &#x3D; Arrays.asList(arr);<br>33.property  get set 的内容<br>    区别于field<br>#34.单列集合(实现Collection接口) :]]<br>###List (ArrayList  LinkedList Vector)   有序 允许重复  支持索引</p><p>######ArrayList  由数组实现 允许null 基本等同Vector<br>线程不安全  增删效率低(数组)  查改效率高(索引)<br>默认容量为0 第一次扩容为10  此后1.5倍扩容<br>指定容量时,1.5倍扩容  Arrays.copy()方法扩容</p><p>LinkedList 双向链表  双端队列    可以存null<br>线程不安全<br>添加和删除不是通过数组,增删效率高,查改效率低(无索引)</p><p>查找较多用ArrayList  增删较多用LinkedList</p><p>Vector 由可变数组实现,线程安全但效率不高<br>  默认容量10 也可以指定大小    2倍扩容</p><p>Set(  HashSet TreeSet)   无序(添与取顺序不一致) 不允许重复<br> 无索引<br>hashset 底层是hashmap ,而hashmap底层是数组+链表+红黑树<br>1.添加一个元素,得到hash值,再转成索引值<br>2.查table,没有加入 有就equals   equals为真,添加 equals为假,不添加<br>扩容:<br>1.底层hashmap 第一次添加 扩到16  临界值为16<em>加载因子&#x3D;12<br>2. 到临界值 两倍扩容到32 新的临界值 32</em>0.75&#x3D;24 以此类推<br>3.如果单个链表个数&gt;&#x3D;8且table大小&gt;&#x3D;64 转成红黑树</p><p>LinkeHashSet是HashSet子类  底层是数组+双向链表 不能重复<br>有序!(存与取顺序一致)</p><p>TreeSet 底层用TreeMap实现,可以在构造器传入Compareble对元素进行排序</p><p>   #双列集合:Map 接口类 key不能重复,value可以重复  多个id可以有相同值     map.keySet()  map.values()  map.entrySet()<br>              TreeMap 可以在构造器传入Comparable进行元素排序<br>               HashMap(线程不安全) 和其子类LinkedHashMap<br>               HashTable  和其子类 Properties<br>hashtable (kv都不能为空,线程安全 初始化为11 临界系数0.75<br>  2倍+1扩容) </p><p>#集合的选择<br>  单列(Collection接口)<br>      有重复List<br>          查改多:ArrayList (数组有索引,查找快)<br>          增删多:LinkedList  双向链表<br>      无重复:Set<br>          无序:hashset  排序treeset<br>          存取顺序一致:Linkedhashset<br>  双列:Map<br>      键无序:HashMap   键排序TreeMap<br>      键存取顺序一致:LinkedHashMap<br>      读取文件:Properties<br>#Collections工具类  操作集合<br>reverse()   shuffle()  sort(list,Comparable )  swap()  max(list Comparable)<br><img src="https://s2.loli.net/2022/02/16/RQ2rqUhz6aDm9jS.png" alt="image.png"></p><p>#treeSet 添加的对象  必须有CompareTo,要么自己类就有,要么自定义,否则类型转换异常,<br>因为treeSet去重是通过compareto()方法的,返回0,就认为相同元素不添加<br>1.构造器传入Comparable匿名,自定义compareTo  2.添加对象自己实现的compareTo</p><p><img src="https://s2.loli.net/2022/02/16/l3ZsOVxRmtNuB5Q.png" alt="image.png"><br>#泛型:某一个类型<br>好处:1.约束数据类型 2.遍历时不需类型转化<br>静态成员不能使用泛型<br>泛型类  泛型方法  使用泛型前必须尖括号声明]<br>&lt;? extends A&gt;  表示 A或者其子类的泛型<br>&lt;? super A&gt; 表示 A或者其父类的泛型<br>#JUnit<br>方便测试某个方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;pubic  谁都可以&lt;br&gt;protected 同包和子类 可以访问&lt;br&gt;默认 同包可以访问&lt;br&gt;private  只有类内访问&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;6.&lt;strong&gt;封装&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://pavaneyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>mybatis-plus使用笔记</title>
    <link href="https://pavaneyu.github.io/2022/02/16/mybatis-plus%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://pavaneyu.github.io/2022/02/16/mybatis-plus%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-16T08:02:14.788Z</published>
    <updated>2022-02-16T08:26:45.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mapper接口对应一张表-关联entity"><a href="#mapper接口对应一张表-关联entity" class="headerlink" title="mapper接口对应一张表,关联entity"></a>mapper接口对应一张表,关联entity</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="使用mapper-操作一张表"><a href="#使用mapper-操作一张表" class="headerlink" title="使用mapper  操作一张表"></a>使用mapper  操作一张表</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">@org.junit.jupiter.api.Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(null);</span><br><span class="line">    users.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h1 id="activeRecord-操作主题是某条记录-代替了mapper-entity继承model-lt-gt"><a href="#activeRecord-操作主题是某条记录-代替了mapper-entity继承model-lt-gt" class="headerlink" title="activeRecord  操作主题是某条记录,代替了mapper , entity继承model&lt;&gt;"></a>activeRecord  操作主题是某条记录,代替了mapper , entity继承model&lt;&gt;</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@TableName(&quot;user&quot;)//excludeProperty</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class User extends Model&lt;User&gt; &#123;</span><br><span class="line">    @TableId(type = IdType.ASSIGN_UUID)//id==primary key</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @TableField(&quot;name&quot;) //默认根据名称自动匹配属性跟列名，默认支持下划线映射驼峰,</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="支持原始自定义mapper和对应xml写SQL"><a href="#支持原始自定义mapper和对应xml写SQL" class="headerlink" title="支持原始自定义mapper和对应xml写SQL"></a>支持原始自定义mapper和对应xml写SQL</h1><p>但要注册xml到系统<code>mybatis-plus.mapper-locations=classpath*:/mapper/**/*.xml </code></p><h1 id="查询queryWrapper-条件-及分组"><a href="#查询queryWrapper-条件-及分组" class="headerlink" title="查询queryWrapper 条件  及分组"></a>查询queryWrapper 条件  及分组</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.jupiter.api.Test</span><br><span class="line">    <span class="keyword">public</span> void test() &#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        users.forEach(System.<span class="keyword">out</span>::println);</span><br><span class="line">        <span class="comment">//  int insert = userMapper.insert(new User(8, &quot;ff&quot;, &quot;dff&quot;));</span></span><br><span class="line">        <span class="comment">//   System.out.println(&quot;insert = &quot; + insert);</span></span><br><span class="line">        HashMap&lt;String, Object&gt; selectMap = new HashMap&lt;&gt;();</span><br><span class="line">        selectMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">        <span class="comment">//默认为true，表示map的查询条件值为null也强制查询，false表忽略null的查询条件</span></span><br><span class="line"></span><br><span class="line">        queryWrapper</span><br><span class="line">                .exists(<span class="string">&quot;select name from user where id&gt;10&quot;</span>)</span><br><span class="line">                <span class="comment">//只有在exists存在记录的情况下才查询</span></span><br><span class="line">                .allEq(selectMap, <span class="literal">false</span>)<span class="comment">//不查询map中值为null的条件</span></span><br><span class="line">                .eq(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;bbb&quot;</span>)<span class="comment">//equalQuery</span></span><br><span class="line">                .ne(<span class="string">&quot;id&quot;</span>, <span class="number">5</span>)<span class="comment">//notEqual</span></span><br><span class="line">                .or()<span class="comment">//连接两个查询条件,默认是and</span></span><br><span class="line">                .gt(<span class="string">&quot;id&quot;</span>, <span class="number">7</span>)<span class="comment">//greaterThan</span></span><br><span class="line">                .ge(<span class="string">&quot;id&quot;</span>, <span class="number">4</span>)<span class="comment">//greaterOrEqual</span></span><br><span class="line">                .lt(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)<span class="comment">//lessThan</span></span><br><span class="line">                .le(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)<span class="comment">//lessOrEqual</span></span><br><span class="line">                .between(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">                .notBetween(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">                .like(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)</span><br><span class="line">                .notLike(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)</span><br><span class="line">                .likeLeft(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)<span class="comment">//左边模糊查询</span></span><br><span class="line">                .likeRight(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)<span class="comment">//</span></span><br><span class="line">                .isNull(<span class="string">&quot;id&quot;</span>)<span class="comment">//查询字段值为null的所有记录</span></span><br><span class="line">                .isNotNull(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .<span class="keyword">in</span>(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>)<span class="comment">//id等于给定值的都返回</span></span><br><span class="line">                .notIn(<span class="string">&quot;id&quot;</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">                .inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where name=b&quot;</span>)<span class="comment">//相当于in查询,不过后面的列表是查询出来的</span></span><br><span class="line">                .notInSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;...&quot;</span>)</span><br><span class="line"></span><br><span class="line">                .orderByAsc(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">                .orderByDesc(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line">                .last(<span class="string">&quot;limit 3&quot;</span>);<span class="comment">//补充的sql放在末尾执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">        list.forEach(System.<span class="keyword">out</span>::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.jupiter.api.Test</span><br><span class="line">    <span class="keyword">public</span> void groupBy() &#123;</span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.select(<span class="string">&quot;name,count(*) &quot;</span>);</span><br><span class="line">        queryWrapper.groupBy(<span class="string">&quot;name&quot;</span>);<span class="comment">//name相同的作为一条记录</span></span><br><span class="line">        List&lt;User&gt; users1 = userMapper.selectList(queryWrapper);</span><br><span class="line"></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;users1 = &quot;</span> + users1);</span><br><span class="line">        users1.forEach(System.<span class="keyword">out</span>::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="默认内存分页-可以配置分页拦截器实现物理分页"><a href="#默认内存分页-可以配置分页拦截器实现物理分页" class="headerlink" title="默认内存分页,可以配置分页拦截器实现物理分页"></a>默认内存分页,可以配置分页拦截器实现物理分页</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class Config &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PaginationInnerInterceptor paginationInnerInterceptor() &#123;</span><br><span class="line">        return new PaginationInnerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">page</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.gt(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Page&lt;User&gt; userPage = userMapper.selectPage(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,<span class="number">3</span>), queryWrapper);</span><br><span class="line">    List&lt;User&gt; records = userPage.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;userPage.getTotal() 总记录数= &quot;</span> + userPage.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;userPage.getPages() 分了几页= &quot;</span> + userPage.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;userPage.getSize() 每页大小= &quot;</span> + userPage.getSize());</span><br><span class="line">    System.out.println(<span class="string">&quot;userPage.getCurrent() 当前页数= &quot;</span> + userPage.getCurrent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="自动生成entity类-service-controller-和原生mapper的xml代码"><a href="#自动生成entity类-service-controller-和原生mapper的xml代码" class="headerlink" title="自动生成entity类  service controller  和原生mapper的xml代码"></a>自动生成entity类  service controller  和原生mapper的xml代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FastAutoGenerator</span><br><span class="line">               .create(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br><span class="line">               .globalConfig(builder -&gt; &#123;</span><br><span class="line">                   builder.author(<span class="string">&quot;ouyang&quot;</span>) <span class="comment">// 设置作者</span></span><br><span class="line">                        <span class="comment">//   .enableSwagger() // 开启 swagger 模式</span></span><br><span class="line">                         <span class="comment">//  .fileOverride() // 覆盖已生成文件</span></span><br><span class="line">                           .outputDir(<span class="string">&quot;D://&quot;</span>); <span class="comment">// 指定输出目录</span></span><br><span class="line">               &#125;)</span><br><span class="line">               .packageConfig(builder -&gt; &#123;</span><br><span class="line">                   builder.parent(<span class="string">&quot;com.ouyang.mpdemo&quot;</span>) <span class="comment">// 设置父包名</span></span><br><span class="line">                          <span class="comment">// .moduleName(&quot;system&quot;) // 设置父包模块名</span></span><br><span class="line">                           .pathInfo(Collections.singletonMap(OutputFile.mapperXml, <span class="string">&quot;com/ouyang/mpdemo/mapper&quot;</span>)); <span class="comment">// 设置mapperXml生成路径</span></span><br><span class="line">               &#125;)</span><br><span class="line">               .strategyConfig(builder -&gt; &#123;</span><br><span class="line">                   builder.addInclude(<span class="string">&quot;t_simple&quot;</span>) <span class="comment">// 设置需要生成的表名</span></span><br><span class="line">                           .addTablePrefix(<span class="string">&quot;t_&quot;</span>, <span class="string">&quot;c_&quot;</span>); <span class="comment">// 设置过滤表前缀</span></span><br><span class="line">               &#125;)</span><br><span class="line">               <span class="comment">//.templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板</span></span><br><span class="line">               .execute();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;mapper接口对应一张表-关联entity&quot;&gt;&lt;a href=&quot;#mapper接口对应一张表-关联entity&quot; class=&quot;headerlink&quot; title=&quot;mapper接口对应一张表,关联entity&quot;&gt;&lt;/a&gt;mapper接口对应一张表,关联entity&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface UserMapper extends BaseMapper&amp;lt;User&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://pavaneyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA 使用技巧</title>
    <link href="https://pavaneyu.github.io/2022/02/16/IDEA%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%20%20/"/>
    <id>https://pavaneyu.github.io/2022/02/16/IDEA%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%20%20/</id>
    <published>2022-02-16T07:58:00.760Z</published>
    <updated>2022-02-18T08:29:05.133Z</updated>
    
    <content type="html"><![CDATA[<p>正则生成和验证弹窗</p><p>返回值为boolean的方法加+! 自动取反</p><p>fixme注释</p><p>.reture<br>.syn<br>.nn<br>逻辑表达式.not  取反<br>.format<br>.field<br>.for    也可以.foreach(方法)拥抱函数式编程</p><span id="more"></span><p>live template<br>大写I    fi</p><p>alt+G   generate<br>alt+n   new<br>Ctrl+O  重写方法<br>c+a+b  查看接口实现类<br>c+h       查看继承关系</p><p>自动导入没有歧义的类和自动删除无用import<br>小写也能识别类<br>多行一起操作 alt+滑鼠左鍵拖拉選取</p><p>1.keymap</p><ul><li>缩进用tab，选中整体右移  左移用shft+tab</li><li>c+&#x2F;   注释单行   第二次取消        c+s+&#x2F;      添加 &#x2F;**&#x2F;注释</li><li>c+hierarchy</li><li>ctrl+J 提示快捷模板</li></ul><p>3.后缀补全<br> .var 自动创建变量,分配变量名<br>.()括号<br>.for<br>4.自定义模板  fi   </p><ul><li>Itit 自动迭代</li><li>大写I  增强for</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;正则生成和验证弹窗&lt;/p&gt;
&lt;p&gt;返回值为boolean的方法加+! 自动取反&lt;/p&gt;
&lt;p&gt;fixme注释&lt;/p&gt;
&lt;p&gt;.reture&lt;br&gt;.syn&lt;br&gt;.nn&lt;br&gt;逻辑表达式.not  取反&lt;br&gt;.format&lt;br&gt;.field&lt;br&gt;.for    也可以.foreach(方法)拥抱函数式编程&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://pavaneyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring笔记</title>
    <link href="https://pavaneyu.github.io/2022/02/16/Spring%E7%AC%94%E8%AE%B0/"/>
    <id>https://pavaneyu.github.io/2022/02/16/Spring%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-16T07:56:40.016Z</published>
    <updated>2022-02-20T07:45:01.923Z</updated>
    
    <content type="html"><![CDATA[<p>IOC  控制反转  :，即把创建对象的过程交给框架，也就是指将对象的创建、对象的存储、对象的管理交给了Spring容器<br>原理:xml解析,工厂模式,反射</p><p>AOP面向切面:不修改源代码进行内容增强 </p><span id="more"></span><p>导入5个包<br>xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);</span><br><span class="line">User user = context.getBean(&quot;user&quot;, User.class); //xml对象名称和类型</span><br></pre></td></tr></table></figure><p>xmlBean里用setter方法设置属性值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> &lt;property name=&quot;name&quot; value=&quot;Ouyang&quot;&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=&quot;name&quot;&gt;</span><br><span class="line">            &lt;null&gt;&lt;/null&gt;   设为null</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">         &lt;property name=&quot;name&quot;&gt;</span><br><span class="line">            &lt;value&gt;&lt;![CDATA[&lt;&lt;Hello&gt;&gt;]]&gt;&lt;/value&gt;  设置特殊值 或者用转义</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">      property内部可以再嵌套一个bean  表示 属性是个类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;likes&quot;&gt;</span><br><span class="line">        &lt;array&gt;                                       设置数组属性</span><br><span class="line">            &lt;value&gt;吃饭&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;睡觉&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">       </span><br><span class="line">        &lt;property name=&quot;map&quot;&gt;         设置map属性</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=&quot;A&quot; value=&quot;B&quot;&gt;&lt;/entry&gt;</span><br><span class="line">                &lt;entry key=&quot;C&quot; value=&quot;D&quot;&gt; &lt;/entry&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">       &lt;property name=&quot;list&quot;&gt;    </span><br><span class="line">            &lt;list&gt;                  设置list&lt;User&gt;属性,先在外层新建好几个Userbean对象</span><br><span class="line">                &lt;ref bean=&quot;user1&quot;/&gt;</span><br><span class="line">                &lt;ref bean=&quot;user2&quot;/&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;bean id=&quot;user2&quot; class=&quot;com.ouyang.User&quot;&gt;   </span><br><span class="line">&lt;!--        对象名            对象类型--&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;lwj&quot;/&gt;  </span><br><span class="line">&lt;!--        属性名              属性值--&gt;</span><br><span class="line">  </span><br><span class="line">  不在list里面对元素赋值 先赋值好再直接引用行不行?</span><br><span class="line">        &lt;property name=&quot;list&quot; ref=&quot;userList&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;util:list id=&quot;userList&quot;&gt;</span><br><span class="line">        &lt;bean id=&quot;user3&quot; class=&quot;com.ouyang.User&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;aa&quot;/&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">        &lt;bean id=&quot;user4&quot; class=&quot;com.ouyang.User&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;bb&quot;/&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/util:list&gt;</span><br></pre></td></tr></table></figure><p>xml里用有参构造器设置属性值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg name=&quot;name&quot; value=&quot;Liu&quot;&gt;&lt;/constructor-arg&gt;</span><br></pre></td></tr></table></figure><p>xml注入集合属性</p><p>工厂bean对象: xml定义的factorybean接口实现类型(真正的返回类型是方法里面)<br> 可以与java里返回的对象类型不一样<br>在java代码里,从文件找,竟然找到一个工厂bean ,那就找工厂的产品 !</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myFactoryBean&quot; class=&quot;com.ouyang.myFactoryBean&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class myFactoryBean implements FactoryBean&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public User getObject() throws Exception &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;oii&quot;);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;com/ouyang/factoryBean.xml&quot;);</span><br><span class="line">User user = context.getBean(&quot;myFactoryBean&quot;, User.class);</span><br></pre></td></tr></table></figure><p><strong>默认bean是singleton,单例,加载xml时自动创建singleton</strong><br> bean属性     scope&#x3D;”prototype”  设置bean为原型  可以有多个对象 ,getBean()才会创建对象</p><p><strong>bean生命周期</strong><br>1.xml构造器创建实例<br>2.xmlsetter设置属性(包括引用其他bean的属性)<br>3.配置初始化方法  bean属性 init-method&#x3D;””<br>4.getBean获取并使用bean<br>5.配置销毁bean方法  bean属性 destroy-method&#x3D;”getObject”  context.close()</p><p><strong>xml中为所有bean添加后置处理器(初始化之前和之后)</strong><br><code>&lt;bean id=&quot;myBeanPost&quot; class=&quot;com.ouyang.myBeanPost&quot;/&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">实现类</span><br><span class="line">public class myBeanPost implements BeanPostProcessor &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;初始化之前调用方法&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;初始化之后调用方法&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>xml自动根据外部bean配置类对象属性</strong> (很少用   ,往往基于注解注入属性)</p><p>bea  n 属性 autowire&#x3D;”byName”    根据外部bean id 配置这个bean中同名属性<br>bean 属性 autowire&#x3D;”byType  “    根据外部bean 类 配置这个bean中同类属性<br>第二种只能有一种外部bean</p><p><strong>xml引入外部文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;classpath:com/ouyang/jdbc.properties&quot;/&gt;   src目录下</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.ouyang.User&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;userName&#125;&quot;/&gt;   key值</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>#注解Bean管理<br><strong>注解创建Bean对象</strong><br>1.springAOP依赖和Annotation依赖<br>2.xml里面或者配置类开启需要组件扫描 的包  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.ouyang&quot;/&gt;</span><br></pre></td></tr></table></figure><p>3.需要创建对象的类上写注解         来创建对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Component(value = &quot;user&quot;) //value(变量名)可以不写,默认为类名(首字母转换为小写)</span><br></pre></td></tr></table></figure><p>4.context.getBean(变量名,bean类型.class)<br> <strong>注意如果创建Bean时注解不设置变量名,则id为首字母小写后的类名</strong></p><p>补充:组件扫描自定义规则 ,比如只扫描Component注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.ouyang&quot; use-default-filters=&quot;false&quot;&gt;</span><br><span class="line">    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Component&quot;/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure><p><strong>注解设置属性</strong><br>1.把A的某个属性设置成B,需要创建AB的Bean,两个类上面都要加注解<br>  在service类上写@Service   在Dao类 写@Repository</p><p>2.在需要设置属性的对象上,写注解<br>@Autowired   根据属性类型  注入对象类型<br>@Qualifier     如果要注入多个同类型bean,根据属性名称  (跟Autowired 一起)<br>@Resource   都行<br>@Value          注入普通类型   </p><p><strong>例如 MyService类中有个Dao类型的属性 ,用注解创建Bean对象,并设置该属性的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;com.ouyang&quot;&#125;)</span><br><span class="line">public class config &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Repository  //</span><br><span class="line">public class Dao  &#123;</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        System.out.println(&quot;dao is adding&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service(value = &quot;myy&quot;)</span><br><span class="line">public class MyService &#123;</span><br><span class="line">//    @Autowired  //按类型注入Bean对象,</span><br><span class="line">//    @Qualifier(value = &quot;dao&quot;)//如果有多个,需要写明对象名称,需要跟 @Autowired一起使用</span><br><span class="line">    @Resource(name = &quot;dao&quot;)</span><br><span class="line">    private Dao basicBao;</span><br><span class="line"></span><br><span class="line">    @Value(value = &quot;32&quot;)</span><br><span class="line">    public int anInt;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        System.out.println(&quot;service add&quot;);</span><br><span class="line">        basicBao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">      //  ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;com/ouyang/Annotation/bean2.xml&quot;);</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(config.class);</span><br><span class="line"></span><br><span class="line">        MyService myService = context.getBean(&quot;myy&quot;, MyService.class);</span><br><span class="line">        myService.add();</span><br><span class="line">        System.out.println(myService.anInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>连接点   可以被增强的方法<br>切入点   实际被增强的方法<br>通知(增强)  增强的逻辑部分<br>   前置<br> 后置通知<br>环绕(前后置)<br>异常通知<br> finally通知<br>1.配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &#123;&quot;com.ouyang.AOP&quot;&#125;) //如果父目录下有相关同名类,一定要细化扫描范围</span><br><span class="line">@EnableAspectJAutoProxy //有Aspect注解的类自动生成代理</span><br><span class="line">public class Config &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.需要增强的类和方法  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component(value = &quot;user&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    public void use() &#123;</span><br><span class="line">        System.out.println(&quot;using&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.增强类   @Aspect 表示要从切面插入的类 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">@Order(1) //如果有多个增强类对同一个方法进行插入增强,设置优先级</span><br><span class="line">public class UserProxy &#123;</span><br><span class="line">    @Pointcut(value = &quot;execution(* com.ouyang.AOP.User.use(..))&quot;)</span><br><span class="line">    public void pointCut() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(value = &quot;pointCut()&quot;)</span><br><span class="line">    //切入点表达式 (权限修饰+被增强类路径+被增强方法+方法参数列表)</span><br><span class="line">    public void before() &#123;</span><br><span class="line">        System.out.println(&quot;before using&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterReturning(value = &quot;pointCut()&quot;)</span><br><span class="line">    public void 返回通知() &#123;</span><br><span class="line">        System.out.println(&quot;前一个执行成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(value = &quot;pointCut()&quot;)</span><br><span class="line">    public void 最终通知() &#123;//不管被插入的地方 有无异常都执行</span><br><span class="line">        System.out.println(&quot;finally&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterThrowing(value = &quot;pointCut()&quot;)</span><br><span class="line">    public void exception() &#123;</span><br><span class="line">        System.out.println(&quot;an exception!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(value = &quot;pointCut()&quot;)</span><br><span class="line">    public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;环绕之前&quot;);</span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(&quot;环绕之后 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用及结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TestAOP &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class);</span><br><span class="line">        User user = context.getBean(&quot;user&quot;, User.class);  //得到被增强的对象</span><br><span class="line">        user.use();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">环绕之前</span><br><span class="line">before using</span><br><span class="line">using</span><br><span class="line">前一个执行成功</span><br><span class="line">finally</span><br><span class="line">环绕之后 </span><br></pre></td></tr></table></figure><p>#JdbcTemplate 的使用<br><strong>应用层  调用逻辑层方法<br>  逻辑指挥层 进行业务操作  只调用实现层方法<br>  具体实现层(包括数据库实现和其他实现 ) 调用API   不涉及业务逻辑<br>  抽象层规定脉络</strong></p><p>##事务<br>ACID<br>原子性 :不可分割  atomicity<br>一致性:事务前后总量一致consistency<br>隔离性:多个事务不会互相影响 isolation<br>持久性:事务提交后,数据库里保存 durability<br>###声明式管理<br>1.xml事务管理器<br>2.xml 注解驱动<br>3.在对应类或方法上面 @Transactional</p><h3 id="Transactional里面的参数"><a href="#Transactional里面的参数" class="headerlink" title="@Transactional里面的参数"></a>@Transactional里面的参数</h3><p>1.propagation  传播   多事务方法直接调用,如何管理  默认required<br><img src="https://upload-images.jianshu.io/upload_images/19490681-8a509372829d34ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>2.ioslation 隔离   避免并发时多事务之间  产生的问题<br>    脏读 一个未提交的事务A读到了另一个未提交的事务B的数据<br>    不可重复读:一个未提交的事务A读到了   已经提交的事务B的修改的数据<br>    幻读:一个未提交的事务A读到了另一个未提交的事务B的提交的数据<br><img src="https://upload-images.jianshu.io/upload_images/19490681-d1e4b11529ba2b3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>3.timeout 默认-1 不计算超时   以秒为单位<br>4.readOnly  默认false<br>5.rollBackFor  哪些异常需要回滚</p><p><strong>完全注解步骤</strong><br>1.config类   几个Bean DataSource  jdbcTemplate   TransactionManager</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 2022-02-05 16:28</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;com.ouyang.JDBCTemplate使用&quot;)</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">public class TxConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public DruidDataSource getDataSource() &#123;</span><br><span class="line">        DruidDataSource druidDataSource = new DruidDataSource();</span><br><span class="line">        druidDataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        druidDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/db01&quot;);</span><br><span class="line">        druidDataSource.setPassword(&quot;&quot;);</span><br><span class="line">        druidDataSource.setUsername(&quot;root&quot;);</span><br><span class="line">        return druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public JdbcTemplate getJdbcTemplate(DataSource dataSource) &#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate = new JdbcTemplate();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        return jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) &#123;</span><br><span class="line">        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();</span><br><span class="line">        dataSourceTransactionManager.setDataSource(dataSource);</span><br><span class="line">        return dataSourceTransactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.业务逻辑层  开启事务   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service(value = &quot;accService&quot;)</span><br><span class="line">@Transactional( readOnly = false,propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ)</span><br><span class="line"></span><br><span class="line">public class AccService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccDao accDao;</span><br><span class="line"></span><br><span class="line">    public void transMoney(String from, String to, int money) &#123;</span><br><span class="line">        accDao.addMoney(money, from);</span><br><span class="line">        //  int i = 10 / 0;</span><br><span class="line">        accDao.reduceMoney(money, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.抽象层  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface AccDao &#123;</span><br><span class="line">    void addMoney(int money,String name);</span><br><span class="line"></span><br><span class="line">    void reduceMoney(int money,String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.数据操作层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class AccDaoImpl implements AccDao&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addMoney(int money, String name) &#123;</span><br><span class="line">        int update = jdbcTemplate.update(&quot;update table_account set money=money-? where name=? &quot;, money, name);</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void reduceMoney(int money, String name) &#123;</span><br><span class="line">        int update = jdbcTemplate.update(&quot;update table_account set money=money+? where name=? &quot;, money, name);</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.应用层<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AccTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;com/ouyang/JDBCTemplate使用/config/Empconfig.xml&quot;);</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(TxConfig.class);</span><br><span class="line"></span><br><span class="line">        AccService accService = context.getBean(&quot;accService&quot;, AccService.class);</span><br><span class="line"></span><br><span class="line">        accService.transMoney(&quot;oyy&quot;,&quot;liu&quot;,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;IOC  控制反转  :，即把创建对象的过程交给框架，也就是指将对象的创建、对象的存储、对象的管理交给了Spring容器&lt;br&gt;原理:xml解析,工厂模式,反射&lt;/p&gt;
&lt;p&gt;AOP面向切面:不修改源代码进行内容增强 &lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://pavaneyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>kotlin学习笔记</title>
    <link href="https://pavaneyu.github.io/2022/02/16/kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://pavaneyu.github.io/2022/02/16/kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-16T07:51:24.205Z</published>
    <updated>2022-02-16T08:26:27.350Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * kotlin中类和方法的参数,可以在创建类的时候指定</span><br><span class="line"> * 不需要setXXX方法传入对象,如果不需要设定,采用默认值</span><br><span class="line"> * 不需要java里面设置null和重载方法(或者构造器)来应对多种参数组合</span><br><span class="line"> * 这也说明kotlin里面方法和类  类似 ,之所以去掉new,因为构造器也是一种方法,返回一个对象</span><br><span class="line"> * 只不过类名一般首字母大写,当然你小写也没关系,只不过这样看起来构造器跟方法没区别了</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">class Test(val int: Int, val str: String, private val char: Char=&#x27;c&#x27;)&#123;</span><br><span class="line">    //类的参数,定义的时候要指明val,可以加访问修饰符</span><br><span class="line">    fun pl()&#123;</span><br><span class="line">        println(int+str.toInt()+char.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun funny(int: Int, str: String, char: Char=&#x27;1&#x27;) &#123;</span><br><span class="line">    println(int+str.toInt()+char.toInt())</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line"></span><br><span class="line">    Test(int = 2,str = &quot;345&quot;).pl()//默认参数可以不指定</span><br><span class="line">    Test( str = &quot;345&quot;, char = &#x27;2&#x27;,int = 3).pl() //指定参数名时候,顺序无所谓</span><br><span class="line">    Test(3,&quot;23&quot;).pl()</span><br><span class="line">    Test(4,&quot;222&quot;,&#x27;2&#x27;).pl()</span><br><span class="line"></span><br><span class="line">    funny(int = 3,char = &#x27;5&#x27;,str = &quot;342&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.返回值为函数类型的函数   是高阶函数</p><p>1.kotlin 类和方法默认public    默认final 不能继承,除非open<br>2.属性引用与函数应用要 类名+::</p><blockquote><p><img src="https://s2.loli.net/2022/02/16/YvIi96UJCMedDmB.png" alt="image.png"></p></blockquote><p>3.labmda表达式最后一行为返回值类型<br>4.</p><blockquote><img src="https://s2.loli.net/2022/02/16/oXebA75JCVQfjvP.png" alt="image.png" style="zoom:50%;"></blockquote><ol start="5"><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//region 注释</span><br><span class="line"></span><br><span class="line">//endregion</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * count what time right show in a String</span><br><span class="line"> */</span><br><span class="line">operator fun String.div(subString: String): Int &#123;</span><br><span class="line">    return this.windowed(subString.length,1)&#123;</span><br><span class="line">        it==subString</span><br><span class="line">    &#125;.count()</span><br><span class="line">&#125;</span><br><span class="line">fun main() &#123;</span><br><span class="line">    println(&quot;asd&quot;/&quot;a&quot;) //运算符重载</span><br><span class="line">    File(&quot;src/SS.java&quot;).inputStream().reader().buffered()</span><br><span class="line">            .use &#123;</span><br><span class="line">                println(it.readLine())</span><br><span class="line">            &#125;</span><br><span class="line">    /**</span><br><span class="line">     * use函数自动关闭closeable和自动捕获异常</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    val student = Student(&quot;asd&quot;, &quot;das&quot;, &quot;sd&quot;)</span><br><span class="line">    /**</span><br><span class="line">     *  also是作为it参数</span><br><span class="line">     *  apply是作为调用对象receiver</span><br><span class="line">     *  返回类型都是调用者的类型</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    val stu1=student.also &#123;</span><br><span class="line">        it.name=&quot;asd&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    val stu2=student.apply &#123;</span><br><span class="line">        name = &quot;asd&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * let用it作为调用对象</span><br><span class="line">     * run用this,可省略</span><br><span class="line">     * 返回类型都是里面函数(lambda表达式)的返回类型</span><br><span class="line">     */</span><br><span class="line">    student.let &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //student.let(::println)</span><br><span class="line">    student.run &#123;</span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">    val list = listOf(1, 2, 3)</span><br><span class="line">    /**</span><br><span class="line">     * filter 接受一个boolean</span><br><span class="line">     * map</span><br><span class="line">     * 不改变原来集合</span><br><span class="line">     */</span><br><span class="line">    val filter = list.filter &#123;</span><br><span class="line">        it % 2 == 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val map = list.map &#123;</span><br><span class="line">        it * 2</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *flatMap将list每一个元素变成集合,再拼接起来</span><br><span class="line">     */</span><br><span class="line">    val flatMap = list.flatMap &#123;</span><br><span class="line">        1 .. it</span><br><span class="line">    &#125;</span><br><span class="line">    println(flatMap.sum())</span><br><span class="line">    println(flatMap)//[1, 1, 2, 1, 2, 3]</span><br><span class="line">    println(list)</span><br><span class="line">    println(filter)</span><br><span class="line">    println(map)</span><br><span class="line">    /**</span><br><span class="line">     * 统计文件里每个字符出现的次数</span><br><span class="line">     */</span><br><span class="line">    File(&quot;src/SS.java&quot;)</span><br><span class="line">            .readText()</span><br><span class="line">            .toCharArray()</span><br><span class="line">            .filter &#123;</span><br><span class="line">                !it.isWhitespace()</span><br><span class="line">            &#125;.groupBy &#123;</span><br><span class="line">                it</span><br><span class="line">            &#125;.map &#123;</span><br><span class="line">                it.key to it.value.size</span><br><span class="line">            &#125;.let &#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><blockquote><img src="https://s2.loli.net/2022/02/16/qDQA1NuGITF7pvk.png" alt="image.png" style="zoom:50%;"></blockquote></li></ol><p>7.密封类(都为抽象类)的子类是有限的 ,枚举类的值是有限的<br>8. &gt; <img src="https://s2.loli.net/2022/02/16/Hx8Wun5IRKVcwyZ.png" alt="image.png" style="zoom:50%;"><br>9. &gt;<img src="https://s2.loli.net/2022/02/16/ZgAOUT2ldDokKqP.png" alt="image.png" style="zoom:50%;"></p><blockquote><p>数据类为final,不可继承  ty</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://pavaneyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis笔记</title>
    <link href="https://pavaneyu.github.io/2022/02/16/Mybatis%E7%AC%94%E8%AE%B0/"/>
    <id>https://pavaneyu.github.io/2022/02/16/Mybatis%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-16T07:46:40.493Z</published>
    <updated>2022-02-16T08:26:49.767Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>0.maven依赖 和build配置   解析java目录下的xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.0.28&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.13&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**/*.properties&lt;/include&gt;</span><br><span class="line">                &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>1.entity   dao接口  和对应的mapper(对应接口信息,对应方法名,返回的entity,sql语句)</p><p>2.配置文件包含</p><ul><li>引入外部文件(可选)</li><li>设置(日志实现)</li><li>类型别名</li><li>数据库连接信息</li><li>注册每个entity对应mapper</li></ul><p>4.getSession</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static SqlSession getSession() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return new SqlSessionFactoryBuilder()</span><br><span class="line">                .build(Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;))</span><br><span class="line">                .openSession();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = MybatisUtils.getSession();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">UserDao userDao = session.getMapper(UserDao.class);</span><br><span class="line">List&lt;User&gt; allUsers = userDao.getAllUsers();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (User user : allUsers) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><p>注意:<br>1.万一数据库字段名  跟entity字段名不一致  使用resultmap ,将返回的不匹配的数据库字段映射成对应的entity字段名,从而返回一个entity<br>2.接口对应的mapper.xml 可以由在接口上加注解代替,注意注册接口mapper<br>反射 实现的动态代理  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Select(&quot;select * from user &quot;)</span><br><span class="line">List&lt;User&gt; getAllUsers();</span><br></pre></td></tr></table></figure><h1 id="多对一-表-查询-1-子查询-2-连表查询"><a href="#多对一-表-查询-1-子查询-2-连表查询" class="headerlink" title="多对一 表  查询  1.子查询  2.连表查询"></a>多对一 表  查询  1.子查询  2.连表查询</h1><p><img src="https://s2.loli.net/2022/02/16/a2vLsiE8SwNFP6X.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/02/16/Fg3ioN4zXJVbYPB.png" alt="image.png"></p><h2 id="sql片段-应用"><a href="#sql片段-应用" class="headerlink" title="sql片段 应用"></a>sql片段 应用</h2><p><img src="https://s2.loli.net/2022/02/16/XO7TBpDRdmh5UjF.png" alt="image.png"></p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>一级缓存: session 级别  DML会刷新缓存,回话关闭,一级缓存才会保存到二级缓存中<br>二级缓存 mapper级别  对应entity需要序列化   缓存保存在map里  </p><pre><code>&lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;6000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;</code></pre><p>缓存策略 :<br>LRU 默认,最近最少使用   移除长时间不被使用的<br>FIFO,  先进先出,  移除先进来的<br><img src="https://s2.loli.net/2022/02/16/S5W6AugR1op3Ced.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;流程&quot;&gt;&lt;a href=&quot;#流程&quot; class=&quot;headerlink&quot; title=&quot;流程&quot;&gt;&lt;/a&gt;流程&lt;/h1&gt;&lt;p&gt;0.maven依赖 和build配置   解析java目录下的xml&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://pavaneyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>git笔记</title>
    <link href="https://pavaneyu.github.io/2022/02/16/git%E7%AC%94%E8%AE%B0/"/>
    <id>https://pavaneyu.github.io/2022/02/16/git%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-16T06:58:20.983Z</published>
    <updated>2022-02-16T08:25:18.912Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><img src="https://s2.loli.net/2022/02/16/iDTFCOUyljVqYu2.png" alt="image-20220216083128939" style="zoom: 33%;"><p>就是保留所有人的修改?  那如果我们修改的是同一块内容呢  已谁为准</p><p>那个分支??   哪个版本?</p><p>1.bash   tab    自动补全</p><p>git init</p><p>git status</p><p>git add XX     添加暂存区</p><p>git reflog  &#x2F;git log</p><p>git reset –hard 版本号     当前分支下的版本穿越</p><p>分支:并行推进多个功能开发   分支合并到master</p><img src="https://s2.loli.net/2022/02/16/pcxmaWMdj69wJv7.png" alt="image-20220216112035521" style="zoom: 50%;"><img src="https://s2.loli.net/2022/02/16/EMQa5I83VpjoDTU.png" alt="image-20220216112123008" style="zoom:50%;">]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;



&lt;img src=&quot;https://s2.loli.net/2022/02/16/iDTFCOUyljVqYu2.png&quot; alt=&quot;image-20220216083128939&quot; style=&quot;zoom: 33%;&quot;&gt;

</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://pavaneyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式笔记</title>
    <link href="https://pavaneyu.github.io/2022/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>https://pavaneyu.github.io/2022/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2022-02-15T02:12:54.583Z</published>
    <updated>2022-02-17T08:30:31.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>UML 原型设计模式</p><p>原型的深浅拷贝   深拷贝的 两种实现方式  重写clone  实现序列化</p><p>Spring 用到哪些设计模式   </p><p>bean的创建就是原型设计模式 ,源码getBean实现?    追到isPrototype</p><p>七大设计原则   核心思想   </p><span id="more"></span><p>实现开发项目中,哪里使用了 OCP原则</p><img src="https://s2.loli.net/2022/02/15/b3eH6l7YujNItxr.png" alt="image-20220215101722302" style="zoom: 80%;"><p>解释器模式  UML? Spring中哪里用到了</p><h1 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h1><p>便于新功能拓展,不需要改变太多源代码  ,提高代码重用性</p><p>规范 提高可读性  </p><p>是程序高内聚低耦合</p><p>在实现功能的基础上,以大项目的角度,解决以上问题</p><p>所以不要问明明可以这样做,为什么要搞这么复杂呢</p><h1 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h1><p>1.单一职责原则:    一个类只有一个功能,防止改变某个功能影响到另外功能</p><p>2.接口隔离原则: 最小接口原则,一个方法形参是B接口  实参是B接口的实现类C  就应该调用B的全部方法,如果不是,那么应该把接口B拆开,再来做形参 </p><p>3.依赖倒置原则:面向接口编程,</p><p>细节实现抽象,低层依赖高层. </p><p>抽象意味着稳定,目的是总体设计规范,不涉及具体操作,细节交给实现类</p><p>4.里氏替换:在子类B中尽量不要重写父类A已经实现的方法,如果需要,可以让AB都继承Base</p><p>5.开闭原则:当软件功能需要增加时,尽量外部拓展,而不是去修改他</p><p>6.最少知道原则:只与你的朋友通信</p><p>7.合成复用原则 如果B要使用A的方法.尽量使用关联聚合组合(要么B使用A当属性,要么B里面new一个A)   而不是B继承A</p><h1 id="classification"><a href="#classification" class="headerlink" title="classification"></a>classification</h1><p>1.build </p><h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><p>0.private construct </p><p>1.double check,check null in synchronized code block   , Thread safety,  lazy</p><p>2.static inner class</p><p>3.enum class </p><p><img src="https://s2.loli.net/2022/02/15/T2ucSBQZKaloUhk.png" alt="image-20220215184127132"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package 设计模式.单例;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 2022-02-15 16:25</span><br><span class="line"> */</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;//构造器私有,防止外面new,对外只提供get方法</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    public  static Singleton singleton;</span><br><span class="line">//   /*</span><br><span class="line">//   private final static Singleton SINGLETON = new Singleton();</span><br><span class="line">//    //在get方法之外之外new静态变量在类加载时候完成,可能这个时候不需要</span><br><span class="line">//    public static Singleton getSINGLETON() &#123;</span><br><span class="line">//        return SINGLETON;</span><br><span class="line">//    &#125;*/</span><br><span class="line">//</span><br><span class="line">//    /**</span><br><span class="line">//     *   efficiency low</span><br><span class="line">//     * @return</span><br><span class="line">//     */</span><br><span class="line">//    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">//        if (singleton == null) &#123;</span><br><span class="line">//           singleton = new Singleton();</span><br><span class="line">//        &#125;</span><br><span class="line">//</span><br><span class="line">//        return singleton;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * perfect ,  double check,check null in synchronized code block   , Thread safety,  lazy</span><br><span class="line">     */</span><br><span class="line">    private static volatile Singleton singleton;</span><br><span class="line">    //什么时候使用volatile呢？当一个线程需要立刻读取到另外一个线程修改的变量值的时候</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * static inner class ,perfect</span><br><span class="line">     */</span><br><span class="line">    private static class SingletonInstance &#123;</span><br><span class="line">        private static final Singleton SINGLETON = new S ingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton gettInstance() &#123;</span><br><span class="line">        return SingletonInstance.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂模式-创建者与调用者分离"><a href="#工厂模式-创建者与调用者分离" class="headerlink" title="工厂模式:创建者与调用者分离"></a>工厂模式:创建者与调用者分离</h1><p>简单工厂  <strong>调用者这里不需要new了</strong>   </p><p>工厂方法  获取新品牌的car不需要修改工厂的代码  增加一个新的工厂类就可以</p><p>抽象工厂</p><p>1.创建对象的时候需要很多参数,参数在工厂里设定好,调用者只是得到设定好的对象(bb:可以用默认参数啊)</p><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>如何复制A的内容到B?  </p><p>1.直接 B&#x3D;A.clone()方法赋值   但是这是浅克隆 ,B是和A不一样了,但是B属性和A的属性是同一个对象,地址相同,更改a的属性,b的也会变</p><p>2.重写Object的clone(),在里面里面把属性也clone()一下赋值,才是深拷贝</p><h1 id="建造者模式-构建与表示相分离"><a href="#建造者模式-构建与表示相分离" class="headerlink" title="建造者模式:构建与表示相分离"></a>建造者模式:构建与表示相分离</h1><p>通过build(xx)链式编程 可以自定义参数  和参数的顺序 (自定义参数可以用kotlin里面的指定参数啊)</p><p>我的意思是,build的功能完全可以被代替</p><hr><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>方法参数是A,但是我们只有C,</p><h1 id="iterator-集合的遍历与实现无关"><a href="#iterator-集合的遍历与实现无关" class="headerlink" title="iterator:集合的遍历与实现无关"></a>iterator:集合的遍历与实现无关</h1><p>就算修改了集合源代码,遍历功能不需要改动,保证遍历代码的可复用性</p><p>(bb:自带的集合还需要用迭代器吗,又不用修改,直接forEach()不香吗)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;UML 原型设计模式&lt;/p&gt;
&lt;p&gt;原型的深浅拷贝   深拷贝的 两种实现方式  重写clone  实现序列化&lt;/p&gt;
&lt;p&gt;Spring 用到哪些设计模式   &lt;/p&gt;
&lt;p&gt;bean的创建就是原型设计模式 ,源码getBean实现?    追到isPrototype&lt;/p&gt;
&lt;p&gt;七大设计原则   核心思想   &lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://pavaneyu.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员,但也是艺术家</title>
    <link href="https://pavaneyu.github.io/2022/02/14/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/"/>
    <id>https://pavaneyu.github.io/2022/02/14/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/</id>
    <published>2022-02-14T09:34:16.408Z</published>
    <updated>2022-02-14T13:10:37.658Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>(1) 使用计算机以及所有有助于了解这个世界本质的事物都不应受到任何限制。任何事情都应该亲手尝试。<br>(Access to computers-and anything that might teach you something about the way the world works-should be unlimited and total. Always yield to the Hands-On Imperative!)<br>(2) 信息应该全部免费。<br>(All information should be free.<br>(3) 不信任权威，提倡去中心化。</p></blockquote> <span id="more"></span><blockquote><p>(Mistrust Authority-Promote Decentralization.)<br>(4) 判断一名黑客的水平应该看他的技术能力，而不是看他的学历、年龄或地位等其他标准。<br>(Hackers should be judged by their hacking, not bogus criteria such as degrees, age, race, or position.)<br>(5) 你可以用计算机创造美和艺术。<br>(You can create art and beauty on a computer.)<br>(6) 计算机使生活更美好。<br>(Computers can change your life for the better.)</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;(1) 使用计算机以及所有有助于了解这个世界本质的事物都不应受到任何限制。任何事情都应该亲手尝试。&lt;br&gt;(Access to computers-and anything that might teach you something about the way the world works-should be unlimited and total. Always yield to the Hands-On Imperative!)&lt;br&gt;(2) 信息应该全部免费。&lt;br&gt;(All information should be free.&lt;br&gt;(3) 不信任权威，提倡去中心化。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://pavaneyu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="思考" scheme="https://pavaneyu.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>奇点降临</title>
    <link href="https://pavaneyu.github.io/2022/02/14/%E5%A5%87%E7%82%B9%E9%99%8D%E4%B8%B4/"/>
    <id>https://pavaneyu.github.io/2022/02/14/%E5%A5%87%E7%82%B9%E9%99%8D%E4%B8%B4/</id>
    <published>2022-02-14T09:30:11.826Z</published>
    <updated>2022-02-15T01:36:54.052Z</updated>
    
    <content type="html"><![CDATA[<p>1.这将是历史上最伟大的进步,这也必将创造新的人类文明,以我们现在甚至无法想象的方式改变世界,进入地球生命进化的新阶段<br>2.运行终极算法的计算机会让我们感觉自己就是天才<br>3.技术进步的步伐会明显加快,不仅仅在计算机科学,其他领域与也是这样,这就会反过来推动生产力发展.<br>4.机器学习就是太阳底下的新鲜事,一种能构建自我的技术<br>5.程序员(创造算法并将其编码的人)是一个小神灵,能创造任意不同的世界,甚至圣经里的神也是程序员,语言是他统治世界 的工具.当今世界,坐在沙发上利用笔记本电脑,你就可以成为一个神. 你完全可以想象一个世界,并实现它</p><span id="more"></span><p>7.代码,是链接碳基生命与硅基生命的桥梁,是人类与机器沟通的语言<br>8.会给出所有学科的统一思想,并有潜力提出新的一套万有理论(可以帮助探寻宇宙的起源和思维的三大问题)<br>9.解释这个时代的内在脉络，揭示它的发展轨迹，帮助你看清我们现在的位置和将来的方向。<br>10.使用计算机以及所有有助于了解这个世界本质的事物都不应受到任何限制。任何事情都应该亲手尝试。<br>11.你可以用计算机创造美和艺术。<br>12.可以通过数据获得过去,现在,未来的所有知识<br>15.真正的自由,解放  </p><p>16.生而为人,为家境出身并不好的人,沉重的陟岵,枷锁,不仅是身体上的环境上的,更是意识上的<br>  让AI成就我,化身一段能自由意识的程序,依靠强大的想象力思维力,自由自在的飞翔在天地之间,<br> 探索这个世界,发现和创造这个世界的美和艺术(音乐,电影,游戏),乃至创造一个全新的世界<br>17.“我们现在看到了它的初期迹象。 生成敌对网络，或GAN。我想在接下来的几年里，我们将看到许多由神经网络发展出的新的神经网络。在接下来的几十年中，A.I.的最大贡献将在于，编写人类根本无法写的软件，解决无法解决的问题。</p><p>18.永生,没有繁殖,万物互联,集体利益<br>19.从欲望的泥沼中脱身</p><ol start="20"><li>物质经济的极大丰富，人不需要为谋生而工作，拥有完全的自由去追求兴趣，充分发挥自己潜能</li><li>重建我们的社会政治结构，走向新世界</li><li>一个有着超人智慧、知识、天赋的姐姐，可以解决我们的个人和社会政治经济问题</li><li>我想创造的是一种可以正常和人交流 ，能学习过往人类的所有知识，<br>能学习人类的经济政治文化社会，并提出和解决矛盾<br>能学习并创作音乐，能创作出象拉威尔那样的曲子<br>文字表达观点和创作文学世界<br>甚至创造电影和游戏世界，创造虚拟现实环境，<br>能思考问题，巨大想象力<br>帮助人类进化，</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;1.这将是历史上最伟大的进步,这也必将创造新的人类文明,以我们现在甚至无法想象的方式改变世界,进入地球生命进化的新阶段&lt;br&gt;2.运行终极算法的计算机会让我们感觉自己就是天才&lt;br&gt;3.技术进步的步伐会明显加快,不仅仅在计算机科学,其他领域与也是这样,这就会反过来推动生产力发展.&lt;br&gt;4.机器学习就是太阳底下的新鲜事,一种能构建自我的技术&lt;br&gt;5.程序员(创造算法并将其编码的人)是一个小神灵,能创造任意不同的世界,甚至圣经里的神也是程序员,语言是他统治世界 的工具.当今世界,坐在沙发上利用笔记本电脑,你就可以成为一个神. 你完全可以想象一个世界,并实现它&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://pavaneyu.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="思考" scheme="https://pavaneyu.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Hexo本地图片引用问题</title>
    <link href="https://pavaneyu.github.io/2022/02/14/hexo%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <id>https://pavaneyu.github.io/2022/02/14/hexo%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-14T04:34:04.998Z</published>
    <updated>2022-02-14T14:01:03.085Z</updated>
    
    <content type="html"><![CDATA[<p>记录一上午搞个人博客的图片问题</p><span id="more"></span><p>0.以前用简书写md,导出的md图片不能正常访问,估计简书防盗链拒绝了其他地方访问其服务器上的图片.</p><p>1.我对图床很排斥,以为用个图片还得先上传到网络,然后拿着url在md文件中引用,太不优雅了</p><p>2.既然md文件不能存储图片信息,那么我把图片跟md文件放在一个文件夹下不就可以</p><p>3.hexo 不能把md附带的文件generate到html  关联</p><p>4.又是下插件,又是搞配置  ,图片是跟html在一起了,结果html对图片的引用是md文件中的链接 原封不动</p><p>关键typora解析md中图片地址是 相对于md文件本身的</p><p>html中  <a href="http://localhost:4000/111/image-20220214100545449.png">http://localhost:4000/111/image-20220214100545449.png</a> 是在public目录下的啊</p><p>5.看来只有更改html中对图片的引用地址了,但是hexo中哪段代码实现了这个我哪里去找啊</p><p>转机</p><p>6.typora设置里有图片上传的功能,查了一下确实可以 粘贴自动把图片上传到云端,并自动引用其地址,</p><p>类似简书</p><img src="https://s2.loli.net/2022/02/14/LYlnA417sU9E2kv.png" alt="image-20220214121843134" style="zoom: 80%;"><p>7.但是要配置2个参数,还要设置一个代理上传到图床的软件,配置好图床token,想用github当图床的</p><p>结果半天没成功,选了个最简单的sm:ms当图床,5GB先用着吧,用几年应该没问题</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一上午搞个人博客的图片问题&lt;/p&gt;</summary>
    
    
    
    <category term="解决问题记录" scheme="https://pavaneyu.github.io/categories/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="博客" scheme="https://pavaneyu.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
